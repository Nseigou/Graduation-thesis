\indent \textbf{DSA (Digital Signature Algorithm)}は, 1993 年に FIPS 186-4として
標準化された, DSS (Digital Signature Standard) の主要なアルゴリズムの
1つであった. なお, 2023 年の FIPS 186-5\cite{fips186-5}では, DSAは
新たにデジタル署名を行うことには推奨されないが, 標準策定以前に行われた
署名の検証には引き続き利用可能とされている.\\
\indent DSAの3つのフェーズにおける処理は以下の通りである.\\
\let\ltxlist\list
\begin{breakitembox}[l]{\textbf{鍵生成}}
  　
  \begin{enumerate}[parsep=7pt]
    \item セキュリティパラメータとして整数 $L,N (L>N)$ を定める. 
    FIPS 186-4では以下の4つの値の組が規定されている.
    \begin{center}
      $(L,N) = (1024,160), (2048,224), (2048,256), (3072,256)$
    \end{center}
    \item $L$ ビットのランダムな素数$p(2^{L-1}<q<2^{L})$, 
    $N$ビットのランダムな素数$q(2^{N-1}<q<2^{N})$ を選ぶ.
    ただし, $q$は$p-1$を割り切る素数とする. 
    \item ランダムな整数$a<p-1$に対し,
    \[
      g\equiv a^{\frac{p-1}{q}}\pmod p
    \] 
    を計算する. ただし, $g=1$である場合は再度$a$を選び直す.
    \item ランダムな整数$x(1<x<q)$に対し,
    \[
      y\equiv g^x\pmod p
    \]
    を計算する.
    \item $p,q,g$は専用のパラメータとして, $y$は検証鍵(公開鍵)として
    公開する. $x$は署名鍵(秘密鍵)として安全に管理する.
  \end{enumerate}
\end{breakitembox}
\vspace{1em}
\indent 任意長のメッセージ $M$ に対して, パラメータ$p, q, g$, 秘密鍵$x$, 
ハッシュ関数$H$ を用いて, 次のように署名を生成する.
\vspace{1em}
\let\ltxlist\list
\begin{breakitembox}[l]{\textbf{署名生成}}
  　
  \begin{enumerate}[parsep=7pt]
    \item ランダムな整数 $k(1<k<q)$ を選ぶ.
    \item $r\equiv (g^k\pmod p)\pmod q$ を計算する. 
    ただし, $r=0$ の場合は再度 $k$ を選び直す.
    \item $s\equiv k^{-1}(H(M+xr))\pmod q$ を計算する.
    ただし, $s=0$ の場合は再度 $k$ を選び直す.
    \item $(r,s)$ をメッセージ$M$に対する署名とし, 
    $M$とともに受信者に送信する.
  \end{enumerate}
\end{breakitembox}
\vspace{1em}
メッセージ$M$に対する署名$(r, s)$を検証するには, パラメータ$(p,q,g)$, 
公開鍵$y$, ハッシュ関数$H$を用いて, 以下のアルゴリズムを実行する.
\vspace{1em}
\let\ltxlist\list
\begin{breakitembox}[l]{\textbf{署名検証}}
  　
  \begin{enumerate}[parsep=7pt]
    \item 受け取った$(r,s)$から, $0<r<q$ かつ $0<s<q$ であることを確認する. 
    これを満たさない場合は署名を棄却する.
    \item $w\equiv s^{-1}\pmod q$ を計算する.
    \item $u_1\equiv wH(M)\pmod q$, $u_2\equiv rw\pmod q$を計算する.
    \item $v\equiv (g^{u_1}y^{u_2}\pmod p)\pmod q$ を計算する.
    \item $v\equiv r\pmod  q$ であれば, 署名を受理する. そうでなければ
    不正な署名とみなし, 棄却する.
  \end{enumerate}
\end{breakitembox}
\vspace{1em}
\indent 正当なメッセージと署名の組$(M, (r, s))$に対し, 
\[
  g^{u_1}y^{u_2}\equiv g^{u_1+xu_2} \equiv g^{H(M)+xr}w\equiv g^{k}\pmod p
\]
が成り立つ. したがって, 正当なメッセージと署名に組には 
\begin{align*}
  v &\equiv (g^{u_1}y^{u_2} \mod p) \mod q \\
    &\equiv (g^k \mod p) \mod q \\
    &\equiv r \mod q
\end{align*}
が成り立つため, $v\equiv r$を満たすかどうかを確認することで
署名検証が可能である.\\
\indent ここで, メッセージや署名に対し改ざんが行われたとしよう. 
攻撃者が, 署名検証条件 $v \equiv r \pmod{q}$ を
満たすように操作できた場合, その攻撃は成功したとみなされる. ただし, 
署名生成に使用される値には, 署名者しか知らない秘密の乱数$k$が
含まれており, この$k$は離散対数問題に基づいて計算されるため, 
十分なビット長を持つ$p$および$q$の下では, 改ざんを成功させることは
計算量的に極めて困難である.さらに, 署名生成プロセスではメッセージの
ハッシュ値$H(M)$が使用されており, このハッシュ値の安全性はハッシュ関数の
衝突困難性に依存している. したがって, 攻撃者が異なるメッセージ $M'$ を
生成し, そのハッシュ値が元のメッセージ $M$ と同じ $H(M') = H(M)$ と
なるようにすることも困難である. この性質により, 改ざんされたメッセージ
$M'$のハッシュ値は$H(M')\neq H(M)$となり, 
署名検証条件 $v \equiv r \pmod{q}$ が成立しなくなる.
また, 攻撃者がメッセージ$M$をそのままにして署名$(r, s)$を
改ざんした場合でも, 署名にはハッシュ値$H(M)$が埋め込まれているため, 
署名検証条件は満たされない. この結果, 署名検証アルゴリズムの最終段階で
署名が有効と判定される場合, 署名$(r, s)$もメッセージ$M$も
改ざんされていないことが保証される.\\[1em]

